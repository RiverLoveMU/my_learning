/**
 * 常用正则表达式
 */

/**
 * 1.验证是否为有效数字
 * 规则分析
 * a.可能出现+ - 号  [+-]?
 * b.一位0到9都可以，多位首位不能为0 (\d|([1-9]\d+))
 * c.小数部分可能有可能没有，一旦有后面必须有小数点加数字(\.\d+)?
 */

let numReg = /^[+-]?(\d|([1-9]\d+))(\.\d+)?$/;

/**
 * 2.验证密码
 * a.数字字母下划线
 * b.6-16位
 */

let passWordReg = /^\w{6,16}$/;

/**
 * 3.验证真实姓名
 * a.汉字  /^[\u4E00-\u9FA5]$/
 * b.名字长度 2-10位
 * c.可能有佚名  ·汉字
 */

let nameReg = /^[\u4E00-\u9FA5]{2,10}(·[\u4E00-\u9FA5]{2,10}){0,2}$/;

/**
 * 4.验证邮箱
 */

let mailReg = /^\w+((-\w+)|(\.\w+))*@[A-Za-z0-9]+((\.|-)[A-Za-z0-9]+)*\.[A-Za-z0-9]+$/;

// => \w+((-\w+)|(\.\w+))*
// 1.开头是数字字母下划线（1到多位）
// 2.接下来是 -数字字母下划线 或者 .数字字母下划线， 整体0到多次
// 邮箱的名字可以 为xx-xx-xx xx.xx.xx xx.xx-xx等模式

//=> @[A-Za-z0-9]+
//1.@后面紧跟着数字字母下划线（1到多位）

//=> ((\.|-)[A-Za-z0-9]+)*
//1,对@后面名字的补充
//多域名邮箱 .com.cn
//企业邮箱 @qianbian-corp-office.com

//=> \.[A-Za-z0-9]+
//1,  匹配最后的域名（.com/.cn/.org 等等）

/**
 * 5.身份证号码
 * 1.一共18位
 * 2.最后一位可能是X
 * 3.身份证前六位：省市县
 * 4.z中间八位: 年月日
 * 5.最后四位：最后一位 x或者数字 倒数第二位 偶数女奇数男
 */

//=>小括号分组的第二个作用：分组捕获，不仅可以把大正则匹配的信息捕获到，还可以单独捕获到每个小分组的内容

let idCardReg = /^(\d{6})(\d{4})(\d{2})(\d{2})\d{2}(\d)(\d|X)$/;

idCardReg.exec('513901199307150214'); // ["513901199307150214", "513901", "1993", "07", "15", "1", "4", index: 0, input: "513901199307150214", groups: undefined]  捕获结果是数组，包含每一个小分组单独获取的内容

/**
 * 正则两种创建方式的区别
 */
//构造函数因为传递的是字符串, \需要写两个转义才能代表斜杠
let reg = /\d+/g;
reg = new RegExp('\\d+', 'g');

// => 正则表达式的部分内容是变量存储的值
// 1.两个斜杠中间包起来的都是元字符（如果正则中要包含某个变量的值，则不能使用字面量方式创建）
// 2. 这种情况只能使用构造函数方式
let type = 'zhufeng';

reg = new RegExp('^@' + type + '@$');

reg.test('@zhufeng@'); //=>true
